<?php
use CG as r;
use CG\Util as u;
use CG\Web as w;
use CG\DB as db;
use CG\Backend as be;

use QuickBooksOnline\API\Core\ServiceContext;
use QuickBooksOnline\API\DataService\DataService;
use QuickBooksOnline\API\PlatformService\PlatformService;
use QuickBooksOnline\API\Core\Http\Serialization\XmlObjectSerializer;
use QuickBooksOnline\API\Facades\Purchase;
use QuickBooksOnline\API\Data\Transaction;
use QuickBooksOnline\API\Data\IPPPurchase;
use QuickBooksOnline\API\QueryFilter\QueryMessage;
use QuickBooksOnline\API\ReportService\ReportService;
use QuickBooksOnline\API\ReportService\ReportName;

use QuickBooksOnline\API\Core\OAuth\OAuth2;
use QuickBooksOnline\API\Core\OAuth\OAuth2\OAuth2AccessToken;

const LOAN_CAT = 11150; // cat of "Other Loans" asset category

// https://help.developer.intuit.com/s/error-resolver

/**
 * @file
 * Common Good QB class
 *
 * Manage our API at https://developer.intuit.com (sign in)
 
 Refer the steps below for regular Oauth integration steps for SAAS apps.For a desktop app either you need to have a web component or a receiver configured for Oauth callback handling or use hard coded tokens.Refer bold section below.Steps for integration with QBO-Please use sandbox QBO accounts ondeveloper.intuit.comfor testing or development.Please refer the following blog post for integrating with QBO API:
 https://developer.intuit.com/blog/2015/04/16/a-3-step-guide-to-getting-started-with-intuit-developer
 https://developer.intuit.com/hub/blog/2016/04/25/quick-start-to-quickbooks-online-rest-api-with-oauth1-0Status 
 
 page for APIs: https://intuitdevelopergroup.statuspage.io/
 
 Go to https://developer.intuit.com/. Create an app on our IDG platform for the QBO v3 apis.You will get a set of consumer key, consumer secret and app token.Set the above keys in the config of your code. Then implement Connect to Quickbooks button:
 https://developer.intuit.com/docs/0100_quickbooks_online/0100_essentials/0001_develop_quickbooks_apps/0004_authentication_and_authorization/connect_from_within_your_app
 
 Then run the code. Your client who has the QBO company can then authorize your code/website to access his QBO company data using Connect to Quickbooks button.Or if you have a sandbox company, then you authorize the code to access your sandbox company.NOTE: For sandbox testing, you need to use dev app keys and sandbox base url.For live/prod qbo company testing, use prod app keys and prod base url after doing a private publish as mentioned below.Go to your app-Prod tab- enter all urls and save. Then get the prod keys from Keys tab under Prod tab of the app. Please refer to:
 https://developer.intuit.com/v2/blog/2014/10/20/changes-to-ipp-app-tokenshttps://developer.intuit.com/blog/2014/10/24/intuit-developer-now-offers-quickbooks-sandboxes
 
 OR if you to connect to your own file, you can generate the oauth tokens from playground. Go to your app-Click Test Connect to Oauth-Intuit Anywhere tab-Set time duration in seconds for 180 days and get the access token and secret for your app and company by right clicking on the page and doing a view source.You will then set of access token and access token secret and realmid/companyid to make api calls for their QBO company which is valid for 180 days.To 'renew tokens', you can call reconnect api after 150 days or do Connect to Quickbooks after 180 days to get new tokens.https://developer.intuit.com/docs/0100_quickbooks_online/0100_essentials/0085_develop_quickbooks_apps/0004_authentication_and_authorization/oauth_management_apiNOTE for desktop apps/automated service type apps-
 
 There is no way to bypass the Oauth process. You will have to do it at least once to make api calls using the Oauth tokens. So, if you have a desktop app/service then you can use Postman or any sample apps we have, add the app keys and then get the Oauth tokens. These are valid for 180 days. Then use app keys and oauth tokens them in your code.


@Dany Yacoub:â€‹ anyway you need to authorize via UI at least one time, then you can refresh an access token in a background. https://developer.intuit.com/docs/00_quickbooks_online/2_build/10_authentication_and_authorization/10_oauth_2.0

According to https://help.developer.intuit.com/s/article/Validity-of-Refresh-Token:
Refresh Token life: 100 days, but may die within "about a day".
Access Token life: 1 hour.
So we get a new refresh token in the background every 4 hours.
 
 */

require_once DRUPAL_ROOT . '/../vendor/autoload.php';
const QB_CHUNK = 500; // how many records to read at once

class QB {
  private $ds = NULL;
  private $helper = NULL;
  private $refreshed = FALSE;
  
  /**
   * Return a new QB object.
   * @param string $creds: the company's credentials for QBO
   * @param bool $refresh: automatically refresh the access token when creating
   */
  public function __construct($creds, $refresh = TRUE) {
    list ($clientId, $secret) = ray($creds);
    
    $ds = $this->ds = DataService::Configure([
      'auth_mode' => 'oauth2',
      'ClientID' => $clientId,
      'ClientSecret' => $secret,
      'RedirectURI' => isPRODUCTION ? BASE_URL . '/qbo' : 'https://cg4.us/qbo.php',
      'scope' => 'com.intuit.quickbooks.accounting', // com.intuit.quickbooks.accounting or com.intuit.quickbooks.payment
  //    'baseUrl' => (isPRODUCTION or isSTAGE) ? 'Production' : 'Development',
      'baseUrl' => 'Production',
    ]);

    $ds->throwExceptionOnError(TRUE);
    $this->helper = $ds->getOAuth2LoginHelper();
    if ($refresh) $this->refresh();
  }
  
  /**
   * Refresh the Access Token -- unless it was refreshed very recently.
   */
  public function refresh() {
    global $channel;

    if ($this->refreshed or test()) return;
    extract(just('rToken rExpires realmId lastRefresh', getv('qboRefresh') ?: [], NULL));
// FAILS   if (now() < $lastRefresh + HOUR_SECS / 2) return; // no need to refresh if done within the past half hour
    
    if ($rExpires > time() + 60) { // at least a minute left to refresh
      $token = $this->helper->refreshAccessTokenWithRefreshToken($rToken);
      $token->setRealmId($realmId); // required (stupid though that is)
      $this->ds->updateOAuth2Token($token);
      $this->setRefreshToken($token, $realmId);
    } elseif ($channel == TX_WEB) { // out of time to refresh (or first time), so reauthorize
      return w\softErr('qbo lost');
    } else return r\tellAdmin(t('Connection lost to QBO'), ray(t('Alert'), tr('qbo lost')));
  }

  /**
   * Get a new refresh token from the given token and realmId, and remember it.
   */
  private function setRefreshToken($token, $realmId) {
    $ray = ray('rToken rExpires realmId lastRefresh', $token->getRefreshToken(), strtotime($token->getRefreshTokenExpiresAt()), $realmId, now());
    setv('qboRefresh', $ray); // store refreshToken so we don't have to re-authorize each time
    $this->refreshed = TRUE;
  }
  
  /**
   * Reauthorize (foreground only)
   *   If called with no GET parameters, provide a link to get a refresh token from scratch.
   *   Otherwise set the refresh token, given the authorization parameters in $_GET
   * @param $_GET: authorization parameters OR nothing (to redirect and get authorization parameters)
   */
  public function auth() {
    extract(just('code realmId', $_GET, NULL));

    if (!$code) return w\say(t('Click <%a>here</a> to set QBO Refresh Token.', '_a', w\atag($this->helper->getAuthorizationCodeURL())));

    $token = $this->helper->exchangeAuthorizationCodeForToken($code, $realmId);
//    delv('qboRefresh'); // force refresh even if it just happened
    $this->setRefreshToken($token, $realmId);
    return w\sayEmpty('QBO Refresh Token has been set.');
  }
  
  /**
   * Return a list of active Income and Expense accounts, keyed by id.
   */   
  public function getAccounts() {
    $this->refresh();
    $ray = $this->getRows('*', 'Account', 'Active ORDERBY FullyQualifiedName'); // '*' so we don't loop through records twice

    $res = [];
    foreach ($ray as $acct) {
      extract(just('Id FullyQualifiedName Description Classification', $acct));
      $type = strtr($Classification[0], ray('R E A L', 0,1,2,3));
      if (!strhas($FullyQualifiedName, 'UNUSED')) $res[$Id] =  "$type: " . str_replace(':', ': ', $FullyQualifiedName) . "\t$Description";
    }

    asort($res); // NOTE: Intuit won't sort by account type ("Classification")
    foreach ($res as $k => $v) $res[$k] = 'IEAL'[$v[0]] . substr($v, 1);
    return $res;
  }
  
  /**
   * Send the latest transactions in CG's various accounts to QBO.
   */
  public function sendTxs() {
    global $testQbTxs;
    
    $start = strtotime('1/1/2021');
    $this->refresh();
    $cnt = 0;

    $txs = $start ? be\getTxs(r\catUids(FALSE), $start, now(), ray('includeSelfTxs catsOnly', TRUE, TRUE)) : [];

    foreach ($txs as $entries) {
      extract(just('xid description created banking cat2 uid2 name', $entries[0]));
      if ($banking) {
        if (r\acct($uid2)->sponsored) $description = strtolower(u\word9(db\get('category', 'tx_cats', ray('cat', $cat2)), ': '));
      } else $description .= " [$name]";
      $info = ray('DocNumber PrivateNote TxnDate', "cg#$xid", $description, fmtDt($created, 'YYYY-MM-dd'));
      $qbTx = new QuickBooksOnline\API\Data\IPPJournalEntry($info);

      foreach ($entries as $tx) $this->addTxLine($qbTx, $tx, $description);
      
      if (test()) $testQbTxs[] = $qbTx; else
      $this->ds->Add($qbTx);
      db\setFlag('tx_hdrs', $xid, B_QBOK);
//      debug($qbTx);
      $cnt++; if ($cnt > 50) break; // debug(
    }
    list ($xid1, $xid9) = $txs ? [$txs[0][0]['xid'], $xid] : ['', ''];
//    r\tellAdmin(t('QBO export complete'), ray('count xid1 xid9', sizeOf($txs), $xid1, $xid9));
    w\say(t('QBO export complete: ') . pr(ray('count xid1 xid9', sizeOf($txs), $xid1, $xid9)));
  }

  /**
   * Send the latest batches of CG bank transfers QBO.
   */
  public function sendBankTxs() {
    global $testQbTxs;
    
    $start = strtotime('4/19/2021');
    $this->refresh();
    $tx0 = ray('uid1 cat1 uid2 cat2', '', '', UID_BANK, db\get('id', 'tx_cats', "nick='POOL'")); // same asset and liability categories for all entries
    $cnt = 0;

    $sql = <<< X
      SELECT deposit, bankTxId, (MIN(txid)<0 AND SUM(1)=1) AS reversal, SUM(amount) AS amt, SUM(1) AS txCnt,
      SUM(IF(amount<0, 0, amount)) AS amtIn, SUM(IF(amount<0, 0, 1)) AS cntIn,
      SUM(IF(amount<0, amount, 0)) AS amtOut, SUM(IF(amount<0, 1, 0)) AS cntOut
      FROM txs2 
      WHERE deposit>=:start AND qbok IS NULL AND bankAccount IS NOT NULL
      GROUP BY deposit, bankTxId
X;
///  AND bankTxId<>0 (add this soon)
    $q = db\q($sql, compact('start'));

    while ($row = $q->fetchAssoc()) {
      extract($row));
      $DocNumber = "cgFund#$deposit";
      $PrivateNote = $desc = $reversal ? t('reversal') : ($txCnt > 1 ? t('ACH batch') : t('single bank transfer'));
      if (!$reversal) $PrivateNote .= ': ' . t('IN %in (%cntIn), OUT %out (%cntOut)');
      $effectiveDt = $bankTxId ? substr($bankTxId, 8) : u\nextBizDay(u\nextBizTm($deposit)); // at some point all relevant bankTxIds will be set and this will be simpler
      $TxnDate = fmtDt($effectiveDt, 'YYYY-MM-dd');
      $qbTx = new QuickBooksOnline\API\Data\IPPJournalEntry(compact(ray('DocNumber PrivateNote TxnDate'));

      u\EXPECT($cntIn + $cntOut > 0, 'empty deposit');
      if ($cntIn > 0) $this->addTxLine($qbTx, $tx0 + ray('amt', $amtIn), $desc);
      if ($cntOut > 0) $this->addTxLine($qbTx, $tx0 + ray('amt', $amtOut), $desc);
      
      if (test()) $testQbTxs[] = $qbTx; else
//      $this->ds->Add($qbTx);
//      db\q('UPDATE txs2 SET qbok=:NOW WHERE deposit=:deposit', compact('deposit'));
      debug($qbTx);
      $cnt++; if ($cnt > 0) break; // debug(
    }
    list ($xid1, $xid9) = $txs ? [$txs[0][0]['xid'], $xid] : ['', ''];
//    r\tellAdmin(t('QBO export complete'), ray('count xid1 xid9', sizeOf($txs), $xid1, $xid9));
    w\say(t('QBO export complete: ') . pr(ray('count xid1 xid9', sizeOf($txs), $xid1, $xid9)));
  }
  
  /**
   * Add a transaction entry (pair) to a QBO Journal Entry Transaction (or possibly two pairs).
   */
  public function addTxLine($qbTx, $tx, $desc) {
    extract(just('amt', $tx));
    $AMT = abs($amt); // QBO handles only positive amounts
    
    foreach ([1, 2] as $i) if ($tx["cat$i"]) {
      list ($typeA, $typeB) = u\order($i == 2 xor $amt < 0, 'Debit', 'Credit');
      foreach (ray('uid cat') as $k) $$k = $tx["$k$i"];
      $a = r\acct($uid);
      $this->addJLine($qbTx, $typeA, db\get('id', 'tx_cats', ray('nick', $a->mainQid)), $AMT, $desc);
      $this->addJLine($qbTx, $typeB, $cat, $AMT, $desc);
    }
  }

  /**
   * Add a Journal Entry Line to the Journal Entry Transaction.
   * @param IPPJournalEntry $qbTx: (MODIFIED) the QB JournalEntry object to add lines to
   * @param string $PostingType: Debit or Credit
   * @param int $id: CG's internal accounting category ID (record ID in tx_cats)
   * @param numeric $Amount: the transaction amount for the recipient
   * @param string $Description: transaction description
   */
  private function addJLine(&$qbTx, $PostingType, $id, $Amount, $Description) {
    $AccountRef = db\get('externalId', 'tx_cats', compact('id'));
    u\EXPECT(!empty($AccountRef), t('empty AccountRef for cat=%cat in tx %txid', 'cat txid', $id, $qbTx->DocNumber));
    $DetailType = 'JournalEntryLineDetail';
    $$DetailType = new QuickBooksOnline\API\Data\IPPJournalEntryLineDetail(compact(ray('PostingType AccountRef')));
//    if ($id == LOAN_CAT) $$DetailType->Entity = $this->getEntity($Description);
    $line = compact(ray("Description Amount DetailType $DetailType"));
    $qbTx->Line[] = new QuickBooksOnline\API\Data\IPPLine($line);
  }
  
  private function getEntity($desc) {
    $nm = strtr(strstr($desc, '['), ray('[ ]', '', ''));
    return $this->get('Id', 'Customer', tr("DisplayName='%nm'", compact('nm')));
  }
  
  /**
   * Return a field value from one QB record.
   */
  public function get($fld, $tnm, $where = '') {
    $res = $this->getRow($fld, $tnm, $where);
    return ($res ? $res[$fld] : NULL);
  }
  
  /**
   * Return one record array from QB.
   */
  public function getRow($flds, $tnm, $where = '') {
    if (!$rows = $this->getRows($flds, $tnm, $where, 1)) return NULL;
    return (array) $rows[0];
  }
  
  /**
   * Return an array of QB record objects.
   * Not allowed in $where: 0, -1, TRUE, >
   */
  public function getRows($flds, $tnm, $where = '', $max = 999999) {
    $this->refresh();
    $where = ($where and $where !== TRUE) ? "WHERE $where" : '';
    if (!$cnt = $this->ds->query("SELECT COUNT(*) FROM $tnm $where")) return NULL;
    $rows = [];
    for ($i = 1; $i <= min($max, $cnt); $i += QB_CHUNK) {
      $rows += $this->ds->query("SELECT * FROM $tnm $where", $i, min(QB_CHUNK, $max - sizeOf($rows)));
    }
    if ($flds != '*') foreach ($rows as $i => $row) $rows[$i] = just($flds, $row); // QBO API doesn't handle field list
    return $rows;
  }

}
