<?php
use CG as r;
use CG\Util as u;
use CG\Web as w;

use QuickBooksOnline\API\Core\ServiceContext;
use QuickBooksOnline\API\DataService\DataService;
use QuickBooksOnline\API\PlatformService\PlatformService;
use QuickBooksOnline\API\Core\Http\Serialization\XmlObjectSerializer;
use QuickBooksOnline\API\Facades\Purchase;
use QuickBooksOnline\API\Data\IPPPurchase;
use QuickBooksOnline\API\QueryFilter\QueryMessage;
use QuickBooksOnline\API\ReportService\ReportService;
use QuickBooksOnline\API\ReportService\ReportName;

use QuickBooksOnline\API\Core\OAuth\OAuth2;
use QuickBooksOnline\API\Core\OAuth\OAuth2\OAuth2AccessToken;
// https://help.developer.intuit.com/s/error-resolver

/**
 * @file
 * Common Good QB class
 * Extends the TCPDF class -- for printing checks, statements, deposit details, etc.
 */

require_once DRUPAL_ROOT . '/../vendor/autoload.php';
const QB_CHUNK = 500; // how many records to read at once

class QB {
  private $ds = NULL;
  private $intent = NULL;
  
  /**
   * Return a new QB object.
   * @param string $creds: the company's credentials for QBO
   * @param string/assoc $args: authorization parameters OR intended op and other parameters
   */
  public function __construct($creds, $args) {
    list ($clientId, $secret) = ray($creds);
    
    $ds = $this->ds = DataService::Configure([
      'auth_mode' => 'oauth2',
      'ClientID' => $clientId,
      'ClientSecret' => $secret,
      'RedirectURI' => isPRODUCTION ? BASE_URL . '/qbo' : 'https://cg4.us/qbo.php',
      'scope' => 'com.intuit.quickbooks.accounting', // com.intuit.quickbooks.accounting or com.intuit.quickbooks.payment
  //    'baseUrl' => (isPRODUCTION or isSTAGE) ? 'Production' : 'Development',
      'baseUrl' => 'Production',
    ]);

    $ds->throwExceptionOnError(TRUE);
    $helper = $ds->getOAuth2LoginHelper();
    extract(just('code realmId', $args, NULL));

    if ($code) {
      $token = $helper->exchangeAuthorizationCodeForToken($code, $realmId);
      $this->intent = r\cook('qboParameters');
    } elseif ($refresh = unserialize(r\cook('qboRefresh')) and $refresh[1] > time() + 60) { // at least a minute left to refresh
      $token = $helper->refreshAccessTokenWithRefreshToken($refresh[0]);
      $token->setRealmId($realmId = $refresh[2]); // required (stupid though that is)
      $ds->updateOAuth2Token($token);
      $this->intent = $args;
    } else { // out of time to refresh (or first time), so reauthorize
      r\setCook('qboParameters', $args, 0);
      return w\go($helper->getAuthorizationCodeURL());
    }

    $ray = [$token->getRefreshToken(), strtotime($token->getRefreshTokenExpiresAt()), $realmId];
    r\setCook('qboRefresh', serialize($ray), 0); // store refreshToken so we don't have to re-authorize each time (must expire with session).
  }

  /**
   * Return a list of active Income and Expense accounts, keyed by id.
   */   
  public function getAccounts() {
//    if (!$cnt = $this->ds->query("SELECT COUNT(*) FROM $tnm")) return debug("Table $tnm is empty.");
    $ray = $this->ds->query("SELECT * FROM Account WHERE Active ORDERBY FullyQualifiedName", 1, 1000);

    $res = [];
    foreach ($ray as $acct) {
      extract(just('Id FullyQualifiedName Description Classification', $acct));
      $type = strtr($Classification[0], ray('R E A L', 0,1,2,3));
      if (!strhas($FullyQualifiedName, 'UNUSED')) $res[$Id] =  "$type: " . str_replace(':', ': ', $FullyQualifiedName) . "\t$Description";
    }

    asort($res); // NOTE: Intuit won't sort by account type ("Classification")
    foreach ($res as $k => $v) $res[$k] = 'IEAL'[$v[0]] . substr($v, 1);
    return $res;
  }
  
  /**
   * Send an account's latest transactions to QBO.
   * @param int $uid: ID of account to process.
   */
  public function sendTxs($uid) {
    $a = r\acct($uid);
    $lastXid = $a->lastQBXid ?: 0;
//    $lastXid = $lastEid ? db\get('xid', 'tx_entries', 'id>=:lastEid', compact('lastEid')) : 0;
    $start = db\min('created', 'tx_hdrs', 'xid>=:lastXid', compact('lastXid')); // get date of last tx even if it was deleted (catches txs whose date got changed)

    $txs = $start ? be\getTxs($uid, $start, now()) : [];
    foreach ($txs as $entries) {
      foreach ($entries as $ei => $tx) {
        extract(just('xid eid created', $tx));
        if ($xid <= $lastXid) continue; // skip already-handled transactions on the start date (or later)
        if ($ei == 0) $qbTx = new \IPPTransaction(['TxnDate' => fmtDt($created, 'Ymd')]);
        $this->addTxLine($qbTx, just('xid description myAmount name cat banking', $tx) + compact('ei'));
      }
//      $this->ds->Add($qbTx);
//      $a->update('lastQBXid', $xid);
    }
    list ($xid1, $xid9) = $txs ? [$txs[0]['xid'], $tx['xid']] : ['', ''];
    r\tellAdmin(t('QBO export of %qid complete', 'qid', $a->mainQid), ray('count xid1 xid9', sizeOf($txs), $xid1, $xid9));
  }

  /**
   * Add a transaction to QBO.
   */
  public function addTxLine($qbTx, $tx) {
    debug($tx);
    extract($tx);
//    debug(getRow(''));
  }
  
  /**
   * Return a field value from one QB record.
   */
  public function get($fld, $tnm, $where = '') {
    $record = $this->getRow($tnm, $where);
    return $record ? just($fld, $record) : NULL;
  }
  
  /**
   * Return one record array from QB.
   */
  public function getRow($tnm, $where = '') {
    if (!$rows = $this->getRows($tnm, $where, 1)) return NULL;
    return (array) $rows[0];
  }
  
  /**
   * Return an array of QB record objects.
   */
  public function getRows($tnm, $where = '', $max = 999999) {
    $where = ($where and $where != TRUE) ? "WHERE $where" : '';
    if (!$cnt = $this->ds->query("SELECT COUNT(*) FROM $tnm $where")) return NULL;
    $rows = [];
    for ($i = 1; $i <= min($max, $cnt); $i += QB_CHUNK) {
      $rows += $this->ds->query("SELECT * FROM $tnm $where", $i, min(QB_CHUNK, $max - sizeOf($rows)));
    }
    return $rows;
  }

  public function intent() {return $this->intent;}
  public function getObj($tnm) {return $this->getRow($tnm);} // not allowed: 0, -1, TRUE, > 
}
